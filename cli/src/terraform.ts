import { execSync } from 'child_process';
import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs/promises';
import path from 'path';
import { RetrieverConfig } from './config.js';

/**
 * Path to the Terraform infrastructure directory
 *
 * Why: The infrastructure Terraform code lives in ../terraform/infrastructure
 * relative to the CLI. We deploy from there.
 */
const TERRAFORM_DIR = path.join(process.cwd(), 'terraform', 'infrastructure');

/**
 * Generates a Terraform .tfvars file from the Retriever configuration
 *
 * Why: Terraform needs variables passed to it. Rather than passing them
 * via command line (which gets messy), we generate a .tfvars file that
 * Terraform automatically loads.
 *
 * The variables map directly to what Terraform expects:
 * - VPC_ID
 * - PUBLIC_SUBNET_ID_1
 * - PUBLIC_SUBNET_ID_2
 * - PRIVATE_SUBNET_ID
 * - CERTIFICATE_ARN
 */
export async function generateTerraformVars(config: RetrieverConfig): Promise<string> {
  if (!config.certificateArn) {
    throw new Error('Certificate ARN is required for deployment');
  }

  const tfvarsContent = `# Generated by Retriever CLI
# This file contains the infrastructure configuration

VPC_ID = "${config.vpcId}"
PUBLIC_SUBNET_ID_1 = "${config.publicSubnetId1}"
PUBLIC_SUBNET_ID_2 = "${config.publicSubnetId2}"
PRIVATE_SUBNET_ID = "${config.privateSubnetId}"
CERTIFICATE_ARN = "${config.certificateArn}"
`;

  const tfvarsPath = path.join(TERRAFORM_DIR, 'terraform.tfvars');

  try {
    await fs.writeFile(tfvarsPath, tfvarsContent, 'utf-8');
    return tfvarsPath;
  } catch (error) {
    console.error(chalk.red('Error writing terraform.tfvars:'), error);
    throw error;
  }
}

/**
 * Checks if Terraform is installed and accessible
 *
 * Why: Before running any Terraform commands, we need to ensure
 * Terraform is installed. This provides a helpful error message
 * if it's not found.
 */
export function checkTerraformInstalled(): boolean {
  try {
    execSync('terraform version', { stdio: 'pipe' });
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Initializes Terraform in the infrastructure directory
 *
 * Why: `terraform init` downloads provider plugins (AWS SDK) and
 * sets up the backend. This must be run before plan or apply.
 */
export async function terraformInit(): Promise<boolean> {
  const spinner = ora('Initializing Terraform...').start();

  try {
    execSync('terraform init', {
      cwd: TERRAFORM_DIR,
      stdio: 'pipe'
    });

    spinner.succeed('Terraform initialized');
    return true;
  } catch (error) {
    spinner.fail('Terraform initialization failed');
    console.error(chalk.red('\nError details:'));
    if (error instanceof Error) {
      console.error(error.message);
    }
    return false;
  }
}

/**
 * Runs terraform plan to preview infrastructure changes
 *
 * Why: Before applying changes, users should see what Terraform
 * will create/modify/destroy. This builds trust and prevents surprises.
 *
 * The plan output shows:
 * - Resources to be created (green +)
 * - Resources to be modified (yellow ~)
 * - Resources to be destroyed (red -)
 */
export async function terraformPlan(): Promise<boolean> {
  const spinner = ora('Generating deployment plan...').start();

  try {
    const output = execSync('terraform plan -no-color', {
      cwd: TERRAFORM_DIR,
      encoding: 'utf-8'
    });

    spinner.succeed('Deployment plan generated');

    console.log(chalk.cyan('\n━━━ Terraform Plan ━━━\n'));
    console.log(output);

    return true;
  } catch (error) {
    spinner.fail('Failed to generate plan');
    console.error(chalk.red('\nError details:'));
    if (error instanceof Error) {
      console.error(error.message);
    }
    return false;
  }
}

/**
 * Applies the Terraform configuration to deploy infrastructure
 *
 * Why: This is the actual deployment step. It creates all the
 * AWS resources: ECS services, load balancer, security groups, etc.
 *
 * We use -auto-approve because the user already confirmed via the
 * interactive prompt in the deploy command.
 */
export async function terraformApply(): Promise<boolean> {
  const spinner = ora('Deploying infrastructure...').start();

  try {
    // Run terraform apply with -auto-approve since we already confirmed
    const output = execSync('terraform apply -auto-approve -no-color', {
      cwd: TERRAFORM_DIR,
      encoding: 'utf-8',
      stdio: 'pipe',
      maxBuffer: 10 * 1024 * 1024 // 10MB buffer for large outputs
    });

    spinner.succeed('Infrastructure deployed successfully!');

    // Show the last part of the output (which includes outputs)
    console.log(chalk.cyan('\n━━━ Deployment Complete ━━━\n'));

    // Extract and show outputs
    const lines = output.split('\n');
    const outputStartIndex = lines.findIndex(line => line.includes('Outputs:'));

    if (outputStartIndex !== -1) {
      console.log(chalk.green('Deployment Outputs:\n'));
      lines.slice(outputStartIndex).forEach(line => {
        console.log(line);
      });
    }

    return true;
  } catch (error) {
    spinner.fail('Deployment failed');
    console.error(chalk.red('\nError details:'));

    if (error instanceof Error && 'stdout' in error) {
      // Show terraform output if available
      const errorOutput = (error as any).stdout?.toString() || (error as any).stderr?.toString();
      if (errorOutput) {
        console.error(errorOutput);
      }
    }

    return false;
  }
}

/**
 * Gets Terraform outputs after deployment
 *
 * Why: Terraform outputs contain important information like:
 * - Load balancer URL
 * - ECS cluster name
 * - Security group IDs
 *
 * We need these to tell the user how to access their deployment.
 */
export async function getTerraformOutputs(): Promise<Record<string, any>> {
  try {
    const output = execSync('terraform output -json', {
      cwd: TERRAFORM_DIR,
      encoding: 'utf-8'
    });

    return JSON.parse(output);
  } catch (error) {
    console.error(chalk.yellow('Warning: Could not retrieve Terraform outputs'));
    return {};
  }
}

/**
 * Validates that the Terraform directory exists
 *
 * Why: Before running any Terraform commands, we should check
 * that the infrastructure directory exists. This helps users
 * understand if they're running the CLI from the wrong location.
 */
export async function validateTerraformDirectory(): Promise<boolean> {
  try {
    await fs.access(TERRAFORM_DIR);

    // Also check for main.tf or similar to confirm it's a Terraform project
    const files = await fs.readdir(TERRAFORM_DIR);
    const hasTerraformFiles = files.some(file => file.endsWith('.tf'));

    if (!hasTerraformFiles) {
      console.error(chalk.red(`\nNo Terraform files found in: ${TERRAFORM_DIR}`));
      return false;
    }

    return true;
  } catch (error) {
    console.error(chalk.red(`\nTerraform directory not found: ${TERRAFORM_DIR}`));
    console.error(chalk.yellow('Please run this command from the Retriever project root directory.'));
    return false;
  }
}