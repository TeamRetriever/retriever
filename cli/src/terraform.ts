import {execSync} from 'child_process';
import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs/promises';
import path from 'path';
import {RetrieverConfig} from './config.js';

/**
 * Path to the Terraform infrastructure directory
 *
 * Why: The infrastructure Terraform code lives in ../terraform/infrastructure
 * relative to the CLI. We deploy from there.
 */
const TERRAFORM_DIR = path.join(process.cwd(), 'terraform', 'infrastructure');

/**
 * Generates a Terraform .tfvars file from the Retriever configuration
 *
 * Why: Terraform needs variables passed to it. Rather than passing them
 * via command line (which gets messy), we generate a .tfvars file that
 * Terraform automatically loads.
 *
 * The variables map directly to what Terraform expects:
 * - VPC_ID
 * - PUBLIC_SUBNET_ID_1
 * - PUBLIC_SUBNET_ID_2
 * - PRIVATE_SUBNET_ID
 * - CERTIFICATE_ARN
 */
export async function generateTerraformVars(config: RetrieverConfig): Promise<string> {
  if (!config.certificateArn) {
    throw new Error('Certificate ARN is required for deployment');
  }

  const tfvarsContent = `# Generated by Retriever CLI
# This file contains the infrastructure configuration

VPC_ID = "${config.vpcId}"
PUBLIC_SUBNET_ID_1 = "${config.publicSubnetId1}"
PUBLIC_SUBNET_ID_2 = "${config.publicSubnetId2}"
PRIVATE_SUBNET_ID = "${config.privateSubnetId}"
CERTIFICATE_ARN = "${config.certificateArn}"
`;

  const tfvarsPath = path.join(TERRAFORM_DIR, 'terraform.tfvars');

  try {
    await fs.writeFile(tfvarsPath, tfvarsContent, 'utf-8');
    return tfvarsPath;
  } catch (error) {
    console.error(chalk.red('Error writing terraform.tfvars:'), error);
    throw error;
  }
}

/**
 * Checks if Terraform is installed and accessible
 *
 * Why: Before running any Terraform commands, we need to ensure
 * Terraform is installed. This provides a helpful error message
 * if it's not found.
 */
export function checkTerraformInstalled(): boolean {
  try {
    execSync('terraform version', {stdio: 'pipe'});
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Ensures the ECS task execution role exists with proper permissions
 *
 * Why: The Terraform configs expect this role to exist, but don't create it.
 * We need to create it with CloudWatch Logs permissions before Terraform runs.
 * This fixes two issues:
 * 1. Missing ecsTaskExecutionRole causing Terraform data source errors
 * 2. Missing logs:CreateLogGroup permission causing ECS task failures
 */
export async function ensureEcsTaskExecutionRole(): Promise<boolean> {
  const spinner = ora('Checking ECS task execution role...').start();
  const roleName = 'ecsTaskExecutionRole';

  try {
    // Check if role exists
    try {
      execSync(`aws iam get-role --role-name ${roleName}`, { stdio: 'pipe' });
      spinner.text = 'Verifying CloudWatch Logs permissions...';

      // Ensure CloudWatch Logs permissions are attached
      const cloudwatchPolicy = {
        Version: "2012-10-17",
        Statement: [{
          Effect: "Allow",
          Action: [
            "logs:CreateLogGroup",
            "logs:CreateLogStream",
            "logs:PutLogEvents"
          ],
          Resource: "arn:aws:logs:*:*:*"
        }]
      };

      execSync(
        `aws iam put-role-policy --role-name ${roleName} --policy-name CloudWatchLogsPolicy --policy-document '${JSON.stringify(cloudwatchPolicy)}'`,
        { stdio: 'pipe' }
      );

      spinner.succeed('ECS task execution role verified');
      return true;

    } catch {
      // Role doesn't exist, create it
      spinner.text = 'Creating ECS task execution role...';

      const trustPolicy = {
        Version: "2012-10-17",
        Statement: [{
          Effect: "Allow",
          Principal: { Service: "ecs-tasks.amazonaws.com" },
          Action: "sts:AssumeRole"
        }]
      };

      execSync(
        `aws iam create-role --role-name ${roleName} --assume-role-policy-document '${JSON.stringify(trustPolicy)}'`,
        { stdio: 'pipe' }
      );

      // Attach standard ECS execution policy
      execSync(
        `aws iam attach-role-policy --role-name ${roleName} --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy`,
        { stdio: 'pipe' }
      );

      // Add CloudWatch Logs permissions
      const cloudwatchPolicy = {
        Version: "2012-10-17",
        Statement: [{
          Effect: "Allow",
          Action: [
            "logs:CreateLogGroup",
            "logs:CreateLogStream",
            "logs:PutLogEvents"
          ],
          Resource: "arn:aws:logs:*:*:*"
        }]
      };

      execSync(
        `aws iam put-role-policy --role-name ${roleName} --policy-name CloudWatchLogsPolicy --policy-document '${JSON.stringify(cloudwatchPolicy)}'`,
        { stdio: 'pipe' }
      );

      spinner.succeed('ECS task execution role created');
      return true;
    }
  } catch (error) {
    spinner.fail('Failed to setup ECS task execution role');
    console.error(chalk.red('\nError details:'));
    if (error instanceof Error) {
      console.error(error.message);
    }
    return false;
  }
}

/**
 * Sets up S3 backend for Terraform state storage
 *
 * Why: Each user deploys to their own AWS account, so we need a unique
 * S3 bucket per account. This function creates a bucket based on the
 * AWS account ID and generates the backend configuration file.
 *
 * The bucket name format: retriever-tfstate-{accountId}
 */
export async function setupS3Backend(region?: string): Promise<string | null> {
  const spinner = ora('Setting up Terraform state storage...').start();
  const awsRegion = region || process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || 'us-east-1';

  try {
    // Get AWS account ID
    const accountId = execSync('aws sts get-caller-identity --query Account --output text', {
      encoding: 'utf-8',
      stdio: 'pipe'
    }).trim();

    const bucketName = `retriever-tfstate-${accountId}`;

    // Check if bucket exists, create if not
    try {
      execSync(`aws s3 ls s3://${bucketName} --region ${awsRegion}`, { stdio: 'pipe' });
      spinner.text = 'State storage bucket found';
    } catch {
      // Bucket doesn't exist, create it
      spinner.text = 'Creating state storage bucket...';

      try {
        // For us-east-1, don't specify LocationConstraint
        if (awsRegion === 'us-east-1') {
          execSync(`aws s3 mb s3://${bucketName} --region ${awsRegion}`, { stdio: 'pipe' });
        } else {
          execSync(
            `aws s3api create-bucket --bucket ${bucketName} --region ${awsRegion} --create-bucket-configuration LocationConstraint=${awsRegion}`,
            { stdio: 'pipe' }
          );
        }

        // Enable versioning for safety
        execSync(
          `aws s3api put-bucket-versioning --bucket ${bucketName} --region ${awsRegion} --versioning-configuration Status=Enabled`,
          { stdio: 'pipe' }
        );

        spinner.text = 'State storage bucket created';
      } catch (createError) {
        spinner.fail('Failed to create state storage bucket');
        console.error(chalk.red('\nError creating S3 bucket. Falling back to local state.'));
        return null;
      }
    }

    // Generate backend config file
    const backendConfigDir = path.join(TERRAFORM_DIR, 'backend_configs');
    const backendConfigPath = path.join(backendConfigDir, 's3_state.tfbackend');

    const backendConfig = `bucket = "${bucketName}"
key    = "retriever/terraform.tfstate"
region = "${awsRegion}"
`;

    try {
      await fs.mkdir(backendConfigDir, { recursive: true });
      await fs.writeFile(backendConfigPath, backendConfig, 'utf-8');
    } catch (writeError) {
      spinner.fail('Failed to write backend config');
      return null;
    }

    spinner.succeed('Terraform state storage configured');
    return backendConfigPath;

  } catch (error) {
    spinner.fail('Failed to setup S3 backend');
    console.log(chalk.yellow('Falling back to local state storage...'));
    return null;
  }
}

/**
 * Initializes Terraform in the infrastructure directory
 *
 * Why: `terraform init` downloads provider plugins (AWS SDK) and
 * sets up the backend. This must be run before plan or apply.
 */
export async function terraformInit(backendConfigPath?: string | null): Promise<boolean> {
  const spinner = ora('Initializing Terraform...').start();

  try {
    let command = 'terraform init';

    // If we have a backend config, use it with -reconfigure to handle backend changes
    if (backendConfigPath) {
      command += ` -backend-config="${backendConfigPath}" -reconfigure`;
    }

    execSync(command, {
      cwd: TERRAFORM_DIR,
      stdio: 'pipe'
    });

    spinner.succeed('Terraform initialized');
    return true;
  } catch (error) {
    spinner.fail('Terraform initialization failed');
    console.error(chalk.red('\nError details:'));
    if (error instanceof Error) {
      console.error(error.message);
    }
    return false;
  }
}

/**
 * Runs terraform plan to preview infrastructure changes
 *
 * Why: Before applying changes, users should see what Terraform
 * will create/modify/destroy. This builds trust and prevents surprises.
 *
 * The plan output shows:
 * - Resources to be created (green +)
 * - Resources to be modified (yellow ~)
 * - Resources to be destroyed (red -)
 */
export async function terraformPlan(): Promise<boolean> {
  const spinner = ora('Generating deployment plan...').start();

  try {
    const output = execSync('terraform plan -no-color', {
      cwd: TERRAFORM_DIR,
      encoding: 'utf-8'
    });

    spinner.succeed('Deployment plan generated');

    console.log(chalk.cyan('\n━━━ Terraform Plan ━━━\n'));
    console.log(output);

    return true;
  } catch (error) {
    spinner.fail('Failed to generate plan');
    console.error(chalk.red('\nError details:'));
    if (error instanceof Error) {
      console.error(error.message);
    }
    return false;
  }
}


/**
 * Applies the Terraform configuration to deploy infrastructure
 *
 * Why: This is the actual deployment step. It creates all the
 * AWS resources: ECS services, load balancer, security groups, etc.
 *
 * We use -auto-approve because the user already confirmed via the
 * interactive prompt in the deploy command.
 *
 * The forceRecreate param allows forcing recreation of all ECS services
 * if needed for troubleshooting.
 */
export async function terraformApply(forceRecreate: boolean = false): Promise<boolean> {
  const spinner = ora('Starting deployment...').start();

  try {
    // Build the terraform apply command
    let command = 'terraform apply -auto-approve -no-color';

    if (forceRecreate) {
      // Force recreation of all ECS services
      spinner.text = 'Force recreation requested - will recreate all ECS services';
      const servicesToReplace = [
        'aws_ecs_service.query',
        'aws_ecs_service.auth_proxy',
        'aws_ecs_service.prometheus',
        'aws_ecs_service.alertmanager',
        'aws_ecs_service.mcp',
        'aws_ecs_service.rvr_collector',
        'aws_ecs_service.rvr_opensearch'
      ];

      servicesToReplace.forEach(svc => {
        command += ` -replace="${svc}"`;
      });
    }

    spinner.succeed('Deploying infrastructure...');
    console.log(chalk.cyan('\n━━━ Terraform Apply ━━━\n'));
    console.log(chalk.gray('This may take several minutes. You\'ll see live progress below:\n'));

    // Run terraform apply with live output streaming
    try {
      execSync(command, {
        cwd: TERRAFORM_DIR,
        stdio: 'inherit', // Stream output directly to user's terminal
      });
    } catch (error) {
      // If terraform fails, execSync throws - we'll handle it in the outer catch
      throw error;
    }

    console.log(chalk.cyan('\n━━━ Deployment Complete ━━━\n'));
    console.log(chalk.green('✓ Infrastructure deployed successfully!\n'));

    return true;
  } catch (error) {
    spinner.fail('Deployment failed');
    console.error(chalk.red('\nError details:'));

    if (error instanceof Error && 'stdout' in error) {
      // Show terraform output if available
      const errorOutput = (error as any).stdout?.toString() || (error as any).stderr?.toString();
      if (errorOutput) {
        console.error(errorOutput);
      }
    }

    return false;
  }
}

/**
 * Gets Terraform outputs after deployment
 *
 * Why: Terraform outputs contain important information like:
 * - Load balancer URL
 * - ECS cluster name
 * - Security group IDs
 *
 * We need these to tell the user how to access their deployment.
 */
export async function getTerraformOutputs(): Promise<Record<string, any>> {
  try {
    const output = execSync('terraform output -json', {
      cwd: TERRAFORM_DIR,
      encoding: 'utf-8'
    });

    return JSON.parse(output);
  } catch (error) {
    console.error(chalk.yellow('Warning: Could not retrieve Terraform outputs'));
    return {};
  }
}


/**
 * Validates that the Terraform directory exists
 *
 * Why: Before running any Terraform commands, we should check
 * that the infrastructure directory exists. This helps users
 * understand if they're running the CLI from the wrong location.
 */
export async function validateTerraformDirectory(): Promise<boolean> {
  try {
    await fs.access(TERRAFORM_DIR);

    // Also check for main.tf or similar to confirm it's a Terraform project
    const files = await fs.readdir(TERRAFORM_DIR);
    const hasTerraformFiles = files.some(file => file.endsWith('.tf'));

    if (!hasTerraformFiles) {
      console.error(chalk.red(`\nNo Terraform files found in: ${TERRAFORM_DIR}`));
      return false;
    }

    return true;
  } catch (error) {
    console.error(chalk.red(`\nTerraform directory not found: ${TERRAFORM_DIR}`));
    console.error(chalk.yellow('Please run this command from the Retriever project root directory.'));
    return false;
  }
}